**Условные обозначения:**

$u$ - номер пользователя  
$i$ - номер товара  
$r_{ui}$ - оценка пользователем $u$ товара $i$  
Иные буквы - различные переменные и промежуточные результаты  
Большой пробел (табуляция) между величинами - разделитель между ключом и значением  
a $\rightarrow$ script.py $\rightarrow$ b - код script.py получает на вход данные a и выдаёт на выходе данные b  
$U$ - количество пользователей  
$I$ - количество фильмов  
$\alpha$ - средняя доля количества оценённых фильмов пользователем (т.е. среднестатистический пользователь оценил $\alpha I$ фильмов, среднестатический фильм был оценён $\alpha U$ пользователями, всего имеется $\alpha UI$ оценок)  
$M$ - число мапперов  
$R$ - число редьюсеров

## До работы
Файл `data/input/ratings.csv` содержит информацию об оценках пользователями фильмов и имеет структуру: $$u_1, i_1, r_{u_1i_1}, timestamp_1 \newline u_2, i_2, r_{u_2i_2}, timestamp_2 \newline ... \newline u_N, i_N, r_{u_Ni_N}, timestamp_N$$

Файл `data/input/movies.csv` содержит информацию о фильмах и имеет структуру:
$$i_1, title_1, genre_1 \\
i_2, title_2, genre_2 \\
... \\
i_M, title_M, genre_M$$

## Первый этап
**mapper_1.py**

Не выполняет никаких вычислений, а преобразовывает запись строки.

`data/input/ratings.csv` $\rightarrow$ mapper\_1.py $\rightarrow$ $$u_1 \quad i_1, r_{u_1i_1} \\ u_2 \quad i_2, r_{u_2i_2} \\ ... \\ u_n \quad i_n, r_{u_ni_n}$$

Сложность по времени одного маппера - $$O(\frac{UI\alpha}{M})$$ - поскольку все мапперы обрабатывают суммарно $UI\alpha$ строк - троек чисел.

Сложность по памяти одного маппера потребляет $$O(1)$$ памяти, поскольку никакие данные нигде не хранятся.

**reducer_1.py**

Для каждого пользователя вычисляет среднюю оценку.  
Для каждого фильма, оценённого пользователем, вычисляет разность оценки фильма и средней оценки пользователя ($dr$).  
Для каждой пары фильмов ($i_1, i_2$), оценённых одним пользователем, записывает $dr_1dr_2, dr_1^2, dr_2^2$

$$u_1 \quad i_{11}, r_{11} \\
... \\ 
u_1 \quad i_{1s_1}, r_{1s_1} \\ 
... \\ 
... \\ 
u_n \quad i_{n1}, r_{n1} \\
... \\ 
u_n \quad i_{ns_n}, r_{ns_n} \\$$ 
$\rightarrow$ reducer\_1.py $\rightarrow$
$$u_1 \quad
i_{11},i_{11},dr_{11}dr_{11},dr_{11}^2,dr_{11}^2 \; ... \; i_{11},i_{1s_1},dr_{11}dr_{1s_1},dr_{11}^2,dr_{1s_1}^2 \;  i_{12},i_{11},dr_{12}dr_{11},dr_{12}^2,dr_{11}^2 \; ... \\
u_2 \quad
i_{21},i_{21},dr_{21}dr_{21},dr_{21}^2,dr_{21}^2 \; ... \; i_{21},i_{2s_1},dr_{21}dr_{2s_1},dr_{21}^2,dr_{2s_1}^2 \;  i_{22},i_{21},dr_{22}dr_{21},dr_{22}^2,dr_{21}^2 \; ... \\
... $$, \\
где $dr_{ui} = r_{ui} - r_{u,avg}$

Например, в **reducer_1.py** было передано
$$1 \quad 2,5.0 \\
1 \quad 3,4.0 \\
1 \quad 5,1.5 \\
2 \quad 5,3.0 $$

То есть пользователь 1 дал товару 2 оценку 5.0, товару 3 - 4.0, товару 5 - 1.5, а пользователь 2 - товару 5 оценку 3.0.
Тогда средний рейтинг пользователя 1 - 3.5, 2 - 3.0.

Тогда **reducer_1.py** выведет (переводы строк добавлены для улучшения читаемости; вычисления в скобках не выводятся, а предназначены для более детального понимания проводимых вычислений):
$$ 1 \quad 
2,2,2.25 (=(5.0-3.5)*(5.0-3.5)),2.25 (=(5.0-3.5)^2),2.25 (=(5.0-3.5)^2) \\ 
2,3,0.75 (=(5.0-3.5)*(4.0-3.5)),2.25 (=(5.0-3.5)^2),0.25 (=(4.0-3.5)^2) \\ 
2,5,-3.0 (=(5.0-3.5)*(1.5-3.5)),2.25 (=(5.0-3.5)^2),4.0 (=(1.5-3.5)^2) \\ 
3,2,0.75 (=(4.0-3.5)*(5.0-3.5)),0.25 (=(4.0-3.5)^2),2.25 (=(5.0-3.5)^2) \\ 
3,3,0.25 (=(4.0-3.5)*(4.0-3.5)),0.25 (=(4.0-3.5)^2),0.25 (=(4.0-3.5)^2) \\ 
3,5,-1.0 (=(4.0-3.5)*(1.5-3.5)),0.25 (=(4.0-3.5)^2),4.0 (=(1.5-3.5)^2) \\ 
5,2,-3.0 (=(1.5-3.5)*(5.0-3.5)),4.0 (=(1.5-3.5)^2),2.25 (=(5.0-3.5)^2) \\ 
5,3,-1.0 (=(1.5-3.5)*(4.0-3.5)),4.0 (=(1.5-3.5)^2),0.25 (=(4.0-3.5)^2) \\ 
5,5,4.0 (=(1.5-3.5)*(1.5-3.5)),4.0 (=(1.5-3.5)^2),4.0 (=(1.5-3.5)^2) \\ 
2 \quad 5,5,0.0 (=(3.0-3.0)*(3.0-3.0)),0.0 (=(3.0-3.0)^2),0.0 (=(3.0-3.0)^2) $$

После того, как на этом этапе отработают все редьюсеры, будут посчитаны все необходимые произведения для вычисления $sim(i,j)$. Действительно, для того, что посчитать все $sim(i,j)$ надо вычислить те и только те произведения $(r_{ui} - r_{u,avg})(r_{uj} - r_{u,avg})$, в которых пользователь $u$ дал оценку товарам $i, j$. Поскольку на редьюсер попадают все значения с одним ключом, то все записи об оценках, касающиеся одного пользователя, придут на один редьюсер, на котором будут посчитаны произведения для каждой из таких пар.

Сложность по времени одного редьюсера - $$O(\frac{U\alpha^2I^2}{R})$$ - поскольку все редьюсеры вместе для каждого из $U$ пользователей совершают порядка $\alpha^2I^2$ операций (вывода, вычитания, умножения). Заметим также, что вместе всеми редьюсерами выводится около $U\alpha^2I^2$ пятёрок чисел - приблизительно по $\alpha^2 I^2$ для каждого пользователя.

Поскольку в любой момент времени каждый редьюсер обрабатывает только одного пользователя (и хранит для него в среднем $O(\alpha I)$ объектов и рейтингов), поэтому потребляемая память - $$O(\alpha I)$$ - на каждый редьюсер.

## Второй этап
**mapper_2.py**

Не выполняет никаких вычислений, а лишь преобразует запись строк. 

$$ u_1 
\quad i_1,i_2,r_{11},r_{12},r_{22} \;
... \;
i_{n_1},i_{n_2},r_{n_1n_1},r_{n_1n_2},r_{n_2n_2}\;
... \\
u_2 
\quad i_3,i_4,r_{33},r_{34},r_{44} \;
... \;
i_{m_1},i_{m_2},r_{m_1m_1},r_{m_1m_2},r_{m_2m_2}\;
... $$
$\rightarrow$
mapper_2.py
$\rightarrow$
$$ i_1,i_2 \quad r_{11},r_{12},r_{22} \\
... \\
i_{n_1},i_{n_2} \quad r_{n_1n_1},r_{n_1n_2},r_{n_2n_2}
... \\
i_3,i_4 \quad r_{33},r_{34},r_{44} \\
... \\
i_{m_1},i_{m_2} \quad r_{m_1m_1},r_{m_1m_2},r_{m_2m_2}
... $$

Сложность одного маппера - $$O(\frac{UI\alpha}{M})$$ - поскольку все мапперы обрабатывают суммарно $UI\alpha$ строк.

В любой момент времени маппер потребляет $$O(1)$$ памяти, поскольку никакие данные нигде не хранятся.

**reducer_2.py**

Суммирует все произведения для каждой пары товаров и делит на среднее геометрическое произведения сумм квадратов (то есть вычисляет $sim(i,j)$)

$$ ... \\
i_1,i_1 \quad ... \\
i_1,i_2 \quad d_1,q_1,s_1 \\
i_1,i_2 \quad d_2,q_2,s_2 \\
i_1,i_2 \quad d_3,q_3,s_3 \\
i_1,i_3 \quad ... \\
... $$
$\rightarrow$
reducer_2.py
$\rightarrow$
$$ ... \\
i_1,i_2 \quad \frac{d_1 + d_2 + d_3}{\sqrt{(q_1 + q_2 + q_3)(s_1 + s_2 + s_3)}} (=sim(i_1, i_2)) \\
... $$

Примечание: по условию задания, если $sim(i, j) < 0$, то надо положить $sim(i, j) = 0$, поэтому в этом случае соответствующая строчка просто не выводится. Это сэкономит немного вычислений и не скажется на результате, но не изменит сложность алгоритма.

Сложность одного редьюсера - $$O(\frac{U\alpha^2 I^2}{R})$$ - поскольку для каждой строки (пятёрки чисел) совершается констаное число операций, а как ранее было замечено, таких пятёрок всего $O(U\alpha^2I^2)$.

В любой момент времени редьюсер потребляет $$O(1)$$ памяти, поскольку хранится только константное число данных.

## Третий этап

**mapper_3.py**

Не производит никаких вычислений, просто переставляет аргументы местами.

$$ i_1, j_1 \quad sim(i_1, j_1) \\
i_2, j_2 \quad sim(i_2, j_2) \\
i_3, j_3 \quad sim(i_3, j_3) \\
... $$
+
`data/input/ratings.csv`

$\rightarrow$
mapper_3.py
$\rightarrow$
$$ j_1 \quad i_1,sim(i_1,j_1),s \\
j_2 \quad i_2,sim(i_2,j_2),s \\
j_3 \quad i_3,sim(i_3,j_3),s \\
... \\
j_1 \quad u_{11}, r_{11}, r \\ 
j_1 \quad u_{12}, r_{12}, r \\ 
... \\ 
j_1 \quad u_{1s_1}, r_{1s_1}, r \\ 
j_2 \quad u_{21}, r_{21}, r \\ 
... \\
j_2 \quad u_{2s_2}, r_{2s_2}, r \\ 
... $$

где символы r-ratings и s-similarities в конце строки указывают на то, откуда пришла данная строка - из матрицы схожести или из оценок.

Сложность одного маппера - $$O(\frac{UI\alpha + I^2}{M})$$ - поскольку все мапперы обрабатывают суммарно $UI\alpha + I^2$ строк - $UI\alpha$ строк из ratings.csv и $O(I^2)$ строк из матрицы сходств.

В любой момент времени маппер потребляет $$O(1)$$ памяти, поскольку никакие данные нигде не хранятся.

**reducer_3.py**

Вычисляет произведения для каждой пары пользователь-товар с одинаковым ключом, а также записывает сходство для них.

$$ ... \\
j_1 \quad u_1, r_{u_1j_1} \\
j_1 \quad u_2, r_{u_2j_1} \\
... \\
j_1 \quad i_1, sim(i_1j_1) \\
j_1 \quad i_2, sim(i_2j_1) \\
... $$
$\rightarrow$
reducer_3.py
$\rightarrow$
$$ ... \\
i_1, u_1 \quad sim(i_1j_1)*r_{u_1j_1}, sim(i_1j_1) \\
i_1, u_2 \quad sim(i_1j_1)*r_{u_2j_1}, sim(i_1j_1) \\
i_2, u_1 \quad sim(i_2j_1)*r_{u_1j_1}, sim(i_2j_1) \\
i_2, u_2 \quad sim(i_2j_1)*r_{u_2j_1}, sim(i_2j_1) \\
... $$

Сложность одного редьюсера - $$O(\frac{U\alpha I^2}{R})$$ - поскольку все редьюсеры вместе умножают (вернее, только совершают необходимое число умножений, сложения - на следующем этапе) плотную (т.е. не разреженную) матрицу размера $I*I$ на матрицу с $\alpha IU$ элементов, для чего требуется $O(\alpha I^2U)$ операций. Число выводимых строк совпадает со сложностью алгоритма, поскольку на подсчёт каждой строки тратится ровно одно умножение.

Примечание: на самом деле, из-за того, что не у каждой пары фильмов есть пользователь, посмотревший оба фильма, а также из-за того, что иногда степень сходства у пару товаров отрицательная, в матрице сходств будет немало нулей. Для простоты положим, что ненулевых элементов в ней $O(I*I)$.

В любой момент времени редьюсер потребляет $$O(I + \alpha U)$$ памяти, поскольку в редьюсере хранятся:
+ $sim(i, j) \quad \forall i \in I$, j - задано
+ $r_{uj} \quad \forall u \in U_{j}$, j - задано

## Четвёртый этап

**mapper_4.py**

Не делает ничего, лишь копируем вход на выход.

Сложность одного маппера - $$O(\frac{U\alpha I^2}{M})$$ - поскольку все мапперы обрабатывают суммарно $U\alpha I^2$ строк.

В любой момент времени маппер потребляет $$O(1)$$ памяти, поскольку никакие данные нигде не хранятся.

**reducer_4.py**

По произведениям и сходствам вычисляет сбалансированную предсказанную оценку (т.е. уже то, что надо сортировать).

$$ ... \\
i_1, u_1 \quad d_1, q_1 \\
i_1, u_1 \quad d_2, q_2 \\
i_1, u_1 \quad d_3, q_3 \\
i_1, u_2 \quad d_4, q_4 \\
... $$
$\rightarrow$
reducer_4.py
$\rightarrow$
$$i_1,u_1 \quad \frac{d_1 + d_2 + d_3}{q_1 + q_2 + q_3}$$

Сложность одного редьюсера - $$O(\frac{U\alpha I^2}{R})$$ - поскольку все редьюсеры вместе обрабатывают все строки, которых $O(\frac{U\alpha I^2}{R})$ штук (маппер не поменял число строк).

В любой момент времени редьюсер потребляет $$O(1)$$ памяти, поскольку никакие данные нигде не хранятся.

## Пятый этап

**mapper_5.py**

Меняет порядок подаваемых данных с (товар-пользователь-рейтинг) на (пользователь-рейтинг-имя товара), где пользователь-рейтинг - ключ, а имя товара - значение, причём id товара заменяется на имя товара при помощи информации из movies.csv. А также выводит список пар (пользователь-товар), для которых уже есть поставленная оценка. Для того, чтобы отличать, какая строчка несёт какую информацию, в начало значения для троек (пользователь-рейтинг-имя товара) добавляется символ 'w', а для пар (пользователь-товар) - символ 'u'.

$$ ... \\
i_1, u_1 \quad r_1 \\
i_2, u_2 \quad r_2 \\
i_3, u_3 \quad r_3 \\
... $$
+
`data/input/ratings.csv`
$\rightarrow$
mapper_5.py
$\rightarrow$
$$ ... \\
u_1 \quad "w"r_1, filmname_1 \\
u_2 \quad "w"r_2, filmname_2 \\
u_3 \quad "w"r_3, filmname_3 \\
... \\
u_1 \quad "u"filmname_1 \\
u_2 \quad "u"filmname_3 \\
... $$

Сложность одного маппера - $$O(\frac{UI}{M})$$ - поскольку все мапперы обрабатывают суммарно $O(UI)$ строк - рейтинги каждого товара для каждого пользователя. Влияение обработки ratings.csv с $\alpha IU$ записей незначительно.

В любой момент времени маппер потребляет $$O(I)$$ памяти, в памяти хранится только словарь id товара - имя товара.

**reducer_5.py**

Сортирует список в соответствии с условиями задания и выводит первые 100 его элементов, причём не выводит те пары (пользователь-товар), которые уже оценены.

$$ ... \\
u_1 \quad "w"r_1, filmname_1 \\
u_2 \quad "w"r_2, filmname_2 \\
u_3 \quad "w"r_3, filmname_3 \\
... \\
u_1 \quad "u"filmname_1 \\
u_2 \quad "u"filmname_3 \\
... $$
$\rightarrow$
reducer_5.py
$\rightarrow$
$$ ... \\
u_1 @ r_{top_{11}} \% filmname_{top_{11}} @ r_{top_{12}} \% filmname_{top_{12}} @ r_{top_{13}} \% filmname_{top_{13}} ... \\
u_1 @ r_{top_{21}} \% filmname_{top_{21}} @ r_{top_{22}} \% filmname_{top_{22}} @ r_{top_{23}} \% filmname_{top_{23}} ... \\
... $$

Сложность одного редьюсера - $$O(\frac{UI\log I}{R})$$ - поскольку все редьюсеры вместе для каждого пользователя сортируют $O(I)$ рейтингов.

Примечание: поскольку необходимо вывести топ-100 товаров, можно $O(I)$ найти 100 наиболее популярных товаров для конкретного пользователя. Несмотря на то, что в таком случае сложность редьюсера упадёт до $O(\frac{UI}{R})$, данный алгоритм не был использован, т.к. тогда фактическое время выполнения сильно бы выросло, поскольку при нашем наборе данных $\log I$ - не очень значительная величина.

В любой момент времени редьюсер потребляет $$O(I)$$ памяти, поскольку в любой момент времени хранится не более $O(I)$ данных - список рейтингов и названий фильмов для каждого из пользователей.